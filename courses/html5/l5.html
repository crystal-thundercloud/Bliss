<!DOCTYPE html>
<html>
	<head>
		<meta charset="UTF-8">
		<meta name="viewport" content="width=device-width,initial-scale=1">
		<link rel="stylesheet" type="text/css" href="../../style/style1.css">
		<link rel="stylesheet" type="text/css" href="../../style/styleheader.css">
		<link rel="stylesheet" type="text/css" href="../../style/lessonsstyle.css">
		<script src="https://ajax.googleapis.com/ajax/libs/jquery/3.5.1/jquery.min.js"></script>
				
		<title>Bliss: онлайн школа языков программирования</title>
	</head>
	
	<body>
		<header>
			<div class="logo">
				<div class="trademark">
					<a href="../../index.html">Bliss</a>
				</div>
				
				<div class="slogan">
					— <i>безмятежное обучение программированию</i>
				</div>
			</div>
			
			<div class="mobilemenu" tabindex="1"><a>/Меню/</a></div>
			
			<div class="menu">
				<a href="../../index.html">/О нас/</a>
				<a href="../../html/courses.html" class="currentpage">/Курсы/</a>
				<a href="../../html/contacts.html">/Контакты/</a>
				<a href="../../html/log.html" id="getinacc">/Войти/</a>
				<a href="../../html/cab.html" id="cabbutton">/Личный кабинет/</a>
				<a href="../../html/adminpage.html" id="adminpage">/Управление/</a>
				<a id="exit">/Выйти/</a>
			</div>
			
			<script src="../../js/mobilemenu.js"></script>
			
			<div id="userinfo">Вы вошли как <a id="userlogin">гость</a></div>
			
			<script src="../../js/getuserlogin.js"></script>
			<script src="../../js/scriptforbuttons.js"></script>
			
		</header>
		
		<div class="maincontainer">
			<div class="content">
				<div class="zagolovok">
					<div class="bread"><a href="../../html/courses.html">Курсы</a> > <a href="../../courses/html5/htmlmain.html">Курс по HTML</a> > Урок 5</div>
					<p id="zglvk">Урок 5. Ещё немного об атрибуте pattern.</p>
				</div>
				
				<div class="page">
					<p> В этом уроке мы продолжаем обсуждать атрибут pattern и его возможности, а для начала снова посмотрим на его значение из предыдущего урока: <text class="nwrp">"[0-9][А-яЁёA-z]{2,6}"</text>. Вспомним, что эта запись означает, что в поле можно ввести ровно одну цифру, после которой должно быть от двух до шести заглавных или строчных букв латинского или кириллического алфавита. Например, текст "1привет" будет принят как валидный.
					<p><input type="text" pattern="[0-9][А-яЁёA-z]{2,6}" placeholder="8ёЖиkОv" required>
					<p>Как думаете, есть ли способ записать то же самое, но покороче?
					<p>Вернёмся к этому вопросу чуть позднее, а сейчас познакомимся со специальными символами (а если придираться к названию - к <i>набору</i> специальных символов), которые помогут нам заменить привычные выражения в квадратных скобках. Все они состоят из двух символов, где первый - обратный слеш, а второй - буква латинского алфавита. Все специальные символы отличаются тем, что их можно писать внутри квадратных скобок, и, в отличие от обычных символов, они будут восприняты верно. То есть не будет такого, как в примере из предыдущих уроков (<b>"привет[|]Привет[|]ПРИВЕТ"</b>), где мы заключили вертикальную черту, означающую "или", в квадратные скобки, и она потеряла своё значение и стала просто чёрточкой, которую пользователь должен вписать в поле.
					<p>Первый символ - <b>\d</b>. Он заменяет запись [0-9]. В следующем поле значение pattern выглядит вот так: <b>"\d"</b> и означает, что поле примет только одну любую цифру. Когда в поле нужно ввести много цифр, согласитесь, куда удобнее написать \d\d\d, чем [0-9][0-9][0-9]?
					<p><input type="text" pattern="\d" placeholder="6" required>
					<p>Также вместо <text class="nwrp">pattern="\d"</text> мы легко можем написать <text class="nwrp">pattern="[\d]"</text>, и ничего не изменится! Но не забудьте, что обратный слэш работает, как и раньше.
					<p>Сразу же познакомимся с противоположностью символа \d - с символом <b>\D</b>. Казалось бы, разница всего лишь в том, что первый имеет строчную букву в своей записи, а второй - заглавную, но на самом деле заглавная буква означает отрицание или <i>инверсию</i>, и значение \D - что угодно, кроме цифры. Следующее поле имеет атрибут pattern со значением <b>"\D"</b> и примет на ввод одну любую букву или символ, но не цифру.
					<p><input type="text" pattern="\D"  placeholder="~" required>
					<p>Второй символ - <b>\s</b>, и он означает пробел, символ табуляции и множество других символов, обозначающих пустое пространство. Чтобы было немного интереснее, в следующем примере значение pattern=<text class="nwrp">"\d\s\d"</text>, что означает, что в поле сначала должна быть любая цифра, затем пробел, а затем ещё одна цифра.
					<p><input type="text" pattern="\d\s\d" placeholder="1 0" required>
					<p>Прямая противоположность символа \s - как вы, возможно, догадались, символ <b>\S</b>. Он примет что угодно - цифру, букву, символ, но не примет пробел.
					<p>Третий символ - <b>\w</b>. Он особенно удобен для составления рекомендаций к вводу логинов, так как означает латинскую букву (заглавную или строчную), любую цифру и нижнее подчёркивание (эквивалент записи <text class="nwrp">[0-9A-z_]</text>). Его злой клон <b>\W</b> не примет ничего из того, что хочет видеть символ \w. Значение атрибута pattern в поле ниже - <text class="nwrp">"\w{5}"</text>.
					<p><input type="text" pattern="\w{5}" placeholder="zAy_c" required>
					</p>
				</div>

				<div class="page hiddenpage">
					<div class="question">Проверьте себя!
						<p>Какой из следующих специальных символов означает пробел или любой другой символ для пустого пространства?
							<br>
							<br>
							<input type="radio" name="q1" id="q11"><label for="q11">\n</label>
							<input type="radio" name="q1" id="q12"><label for="q12">\S</label>
							<input type="radio" name="q1" id="q13"><label for="q13">\t</label>
							<input type="radio" name="q1" id="q14"><label for="q14">\T</label>
							<input type="radio" name="q1" id="q15" class="corrad"><label for="q15">\s</label>
						<p>Какой символ запрещает ввод латинских букв, цифр и знаков подчёркивания?<br>
							<input type="text" id="q2" class="smallinput" pattern="\\W" required>
						<p>Взгляните на следующую запись и отметьте правильные высказывания о поле с таким атрибутом.
							<br>
							<b>pattern="([0-9]\d\s)[3,5]"</b>
							<br>
							<p style="text-align: left;border:none;">
							<input type="checkbox" id="q31" class="corchck"><label for="q31">Сначала в поле пишется ровно две цифры</label>
							<br>
							<input type="checkbox" id="q32"><label for="q32">В поле можно вписать не более трёх цифр подряд</label>
							<br>
							<input type="checkbox" id="q33"><label for="q33">В поле можно вписать от трёх до пяти цифр подряд</label>
							<br>
							<input type="checkbox" id="q34" class="corchck"><label for="q34">После двух цифр обязательно идёт пробел</label>
							<br>
							<input type="checkbox" id="q35"><label for="q35">Конструкция из двух цифр и пробела должна быть написана от трёх до пяти раз</label>
							<br>
							<input type="checkbox" id="q36" class="corchck"><label for="q36">После двух цифр и пробела обязательно должна идти цифра 3 либо цифра 5</label>
							<br><text id="q21h"></text>
							<input type="checkbox" id="q37"><label for="q37">После двух цифр и пробела должно быть написано "3,5"</label>
							<br>
							<center>
								<button id="why1" class="show" onClick="why1()">Почему?</button>
								<button id="whyclose1" class="hide" onClick="whyclose1()">Скрыть подсказку</button>
							</center>
							<div id="bcs1" class="bcs">Посмотрите на запись повнимательнее. Из прошлых уроков мы можем вспомнить, что запись [0-9] означает ввод одной цифры, то же означает и символ \d, поэтому в записи имеем две цифры. После этих символов идёт символ \s, означающий пробел - получаем две цифры и пробел. Дальше мы видим запись, напоминающую по виду запись минимального и максимального количества ввода предыдущих символов, но только она не в фигурных скобках, а в квадратных. Что это значит? В предыдущем уроке мы коротко обговорили такую запись: если элементы в квадратных скобках, значит, они рекомендуемы ко вводу (за исключением специальных символов). То есть в нашей записи идут сначала две любые цифры, затем пробел, а после - либо цифра 3, либо цифра 5, либо запятая. А зачем тогда круглые скобки? Чтобы вас запутать >:3
							<br>
							Если бы цифры 3 и 5 были в фигурных скобках, то круглые скобки помогли бы сгруппировать две цифры и пробел, и они все вместе действительно были бы рекомендованы к вводу от трёх до пяти раз (то есть минимально короткая запись выглядела бы как, например, "32 43 65 ").</div>
						<p>Взгляните на следующее значение атрибута pattern и отметьте запись, которая сделает поле с таким атрибутом валидным.
							<br>
							<b>pattern="[\\d]\s\d"</b>
							<br>
							<br>
							<input type="radio" name="q4" id="q41"><label for="q41">2 4</label>
							<input type="radio" name="q4" id="q42" class="corrad"><label for="q42">\ 6</label>
							<input type="radio" name="q4" id="q43"><label for="q43">\d\s\d</label>
							<input type="radio" name="q4" id="q44"><label for="q44">8 \d</label>
							<input type="radio" name="q4" id="q45"><label for="q45">\d 3</label>
							<br>
							<br>
							<center>
								<button id="why2" class="show" onClick="why2()">Почему?</button>
								<button id="whyclose2" class="hide" onClick="whyclose2()">Скрыть подсказку</button>
							</center>
							<div id="bcs2" class="bcs">Из предыдущих уроков мы помним, что квадратные скобки  превращают текст внутри них в простой набор символов. Однако в этом уроке мы узнали, что специальные символы \d, \D, \s, \S, \w, \W не экранируются скобками и работают, как и раньше. Тем не менее, обратный слеш экранирует идущий после него специальный символ, делая из него просто сочетание "\d", а так как и слеш, и символ \d находятся в квадратных скобках, то оба превращаются в набор символов (\,\,d), из которых к вводу рекомендуем только один. В итоге записи "\ 6" или "d 1" (второй нет среди вариантов ответа) одинаково подойдут к полю с таким значением атрибута pattern.
							<br>
							Если бы квадратных скобок не было, то верным ответом было бы "\d 3" - обратный слеш экранировал бы весь специальный символ \d, а остальные проигнорировал бы - ведь обратный слеш экранирует только один идущий после него специальный символ (а наши \d, \s и \w пускай и состоят из двух символов, но воспринимаются как одно целое).
							</div>
						<p>Сколько цифр должно быть написано в поле, чтобы оно стало валидным, если значение атрибута pattern=<text class="nwrp">"\d[0-9]\d{5}"</text>?
						<br>
						<br>
						<input type="radio" name="q5" id="q51"><label for="q51">3</label>
						<input type="radio" name="q5" id="q52"><label for="q52">5</label>
						<input type="radio" name="q5" id="q53" class="corrad"><label for="q53">7</label>
						<input type="radio" name="q5" id="q54"><label for="q54">15</label>
						<br>
						<br>
						</p>
						<button id="showme1" class="show" onClick="show1()">Показать ответы</button>
						<button id="hideme1" class="hide" onClick="hide1()">Скрыть ответы</button>
					</div>
				</div>
				
				<div class="page hiddenpage">
					<p>Итак, мы немного разобрались с новыми служебными символами. Вернёмся к нашей старой записи. Вот, как она выглядит: <text class="nwrp">"[0-9][А-яЁёA-z]{2,6}"</text>. [0-9] заменим на \d, а [A-z] легко можно заменить на \w. Вот, что получится: <text class="nwrp">pattern="\d[\wА-яЁё]{2,6}"</text>
					<p><input type="text" pattern="\d[\wА-яЁё]{2,6}" placeholder="3мEй_ka" required>
					<p>Но подождите, нам же было нужно, чтобы у нас после цифры шли только буквы! А \w, как мы помним, включает и цифры, и символ подчёркивания. Предположим, что цифры мы, так и быть, переживём, но вот символ подчёркивания мы видеть не хотим. Как же нам это записать?
					<p>Решение - символ отрицания, логическая связка "не", <i>инверсия</i> - великий и могучий карет <b>^</b>, которого часто ошибочно называют циркумфлексом ( &#770; или &#x302;, созданным для особенных букв с "шапочкой" и не являющимся самостоятельным символом). Он ставится сразу после открытия квадратных скобок, содержащих символы,  которые нам точно не нужны (а если его поставить в середине, то он также станет рекомендуемым к вводу). Чтобы далеко не идти, попробуем запретить написание цифры в самом начале: <text class="nwrp">pattern="[^\d][A-zА-яЁё]{2,6}"</text>
					<p> <input type="text" pattern="[^\d][A-zА-яЁё]{2,6}" placeholder="#тYчkА" required>
					<p>Готово! Теперь здесь вообще нельзя написать цифры, а на месте скобки с каретом паттерн требует ввода чего-либо другого - буквы или символа. Казалось бы, куда проще символы, которые мы не хотим видеть, в принципе не записывать в наше регулярное выражение, но бывает так, что нам не нужно, к примеру, чтобы тот же логин начинался с цифры. В таком случае подобная конструкция начинает иметь смысл, но мы её ещё немного доработаем и добавим возможность писать цифры после букв: <text class="nwrp">pattern="[^\d][А-яЁё]{2,6}\d*"</text>
					<p>Вспомнили, что означает символ звёздочки? Любое количество символов (от нуля и до бесконечности), стоящих до неё - в нашем случае это цифра. А чтобы пользователь не увлёкся и не сделал гигантский логин, поставим ограничение на длину текста с помощью <b>maxlength</b> и дадим этому атрибуту значение 11: <b>pattern="[^\d][A-zА-яЁё]{2,6}\d*" maxlength="11"</b>
					<p> <input type="text" pattern="[^\d][A-zА-яЁё]{2,6}\d*" maxlength="11" placeholder="!моRоz625" required>
					<p>Почти то что надо, но запись в первых квадратных скобках с каретом требует ввода чего-либо другого вместо цифры, будь то буква или даже спецсимвол. Но где это видано, чтобы логин со спецсимвола начинался? Давайте лучше напишем конкретно: первый символ - буква: <b>pattern="[A-zА-яЁё][A-zА-яЁё]{2,6}\d*"</b>.
					<p> <input type="text" pattern="[A-zА-яЁё][A-zА-яЁё]{2,6}\d*" maxlength="11" placeholder="гRомNла9000" required>
					<p>Получилось! Теперь у нас в самом начале должна быть буква, после которой обязательно ещё как минимум две буквы, а затем - цифры, которых может быть от нуля и до бесконечности. Не забудем про наш maxlength - не более 11 символов.
					</p>
				</div>
				
				<div class="page hiddenpage">
					<p>Но почему цифры стоят только в конце? Может, мы хотим их видеть и в середине, главное - не в начале. Но в середине можно и буквы писать. Кто нам поможет в этом? Наша связка "или", вертикальная черта |. С помощью круглых скобок сгруппируем буквы и цифры, а между ними поставим чёрточку: <b>pattern="[A-zА-яЁё]([A-zА-яЁё]{2,6}|\d*)"</b>.
					<p> <input type="text" pattern="[A-zА-яЁё]([A-zА-яЁё]{2,6}|\d*)" maxlength="11" placeholder="ЖёLYдb, d19216801" required>
					<p>Теперь другая проблема - мы хотим, чтобы цифры и буквы стояли вперемешку, и чтобы не было такого, что логин состоит только из букв или только из одной буквы и цифр. Заберём фигурные скобки у наших букв и поставим их в конец. Вот, что получилось: <b>pattern="[A-zА-яЁё]([A-zА-яЁё]|\d*){2,6}"</b>. Для этого паттерна мы нарочно не стали задавать maxlength, чтобы вы попробовали вписать разные комбинации букв и цифр.
					<p> <input type="text" pattern="[A-zА-яЁё]([A-zА-яЁё]|\d*){2,6}" placeholder="Ут0чk4" required>
					<p>Немного поясним нашу запись. В начале логина должна стоять ровно одна буква, а что происходит после? В круглых скобках у нас любая буква ЛИБО любое количество цифр, причём они могут быть написаны от двух до шести раз. Чтобы вам было немного проще, превратим запись в <b>pattern="[A-zА-яЁё]([A-zА-яЁё]|\d*){3}"</b>. Если вместо фигурных скобок просто повторить наши круглые скобки столько раз, сколько написано в фигурных, то мы получим следующую запись: <b>pattern="[A-zА-яЁё]([A-zА-яЁё]|\d*)([A-zА-яЁё]|\d*)([A-zА-яЁё]|\d*)"</b>. Это означает, что после буквы может идти буква ИЛИ цифра, затем снова буква ИЛИ цифра, и опять буква ИЛИ цифра. Для такого паттерна валидным будут следующие тексты: "zaaa", "Котя", "А113", "b4m8".
					<p>Чтобы вы лучше поняли, как именно работает постановка фигурных скобок после круглых, следующее поле создано для ввода времени в формате ЧЧ:ММ:СС и значение атрибута pattern  у него - <b>"(0[0-9]|1[0-9]|2[0-3])(:[0-5][0-9]){2}"</b>.
					<p> <input type="text" pattern="(0[0-9]|1[0-9]|2[0-3])(:[0-5][0-9]){2}" placeholder="ЧЧ:ММ:СС" required>
					<p>Поясним эту запись: в первых круглых скобках - часы. Часы не могут быть больше 23. Чтобы упростить себе задачу, мы как бы разделили запись часов на первую цифру и на вторую: первой может быть 0, 1 или 2, а второй - практически любая. Только у нас может быть 19, но не может быть 29 часов, поэтому придётся для каждой из трёх первых цифр отдельно прописывать вторую: 0[0-9], 1[0-9], 2[0-3] (максимум - 23 часа). Так как нам нужно что-то одно из этих трёх вариантов, мы пишем между ними связку "или": 0[0-9]|1[0-9]|2[0-3]. С часами разобрались, переходим к минутам. Мы хотим, чтобы их записывали через двоеточие, поэтому оно стоит первым. Как и с часами, мы разделяем минуты на первую и вторую цифру, где первая не превышает 5 (не может же быть 70 минут), а вторая - любая: :[0-5][0-9]. Но, в общем-то, секунды записываются точно так же, поэтому хорошо бы просто повторить запись и поставить {2} после минут. Только если мы так всё и оставим без круглых скобок, число 2 повторит только самые последние квадратные, а это скобки [0-9]. Получится запись вроде 23:518. Именно для того, чтобы второй раз нужно было написать всё выражение минут, мы оборачиваем их в круглые скобки: (:[0-5][0-9]){2}. Отлично! Теперь два раза нужно будет повторить именно конструкцию в круглых скобках, ну а часы мы тоже заключим в отдельные скобки, чтобы связка "или" поняла, из чего ей нужно выбирать.
					<p>Кстати, чтобы немного укоротить запись, все [0-9] можно заменить на \d. Получится <text class="nwrp">"(0\d|1\d|2[0-3])(:[0-5]\d){2}"</text>.
					</p>
				</div>
				
				<div class="page hiddenpage">
					<p>В средствах работы с регулярными выражениями есть несколько интересных и, иногда, крайне важных для использования методов. Один из них - <i>референсы</i>, также называемые "обратной связью". Так получилось, что каждые не экранированные <u>круглые</u> скобки вашего регулярного выражения незаметно для вас нумеруются слева направо от первого до, обычно, 9 номера. Компьютер запоминает, каким скобкам какая часть вводимого текста соответствует, и может легко возвращаться к ней в будущем и запрашивать её повторный ввод. Обращение к скобке выглядит вот так: <b>\1</b>, где 1 - номер скобок. Разберём на простом примере: <text class="nwrp">pattern="([A-z])\1"</text>.
					<p><input type="text" pattern="([A-z])\1" placeholder="GG" required>
					<p>В этих квадратных скобках - одна заглавная или строчная буква латинского алфавита, а после неё идёт... Она же. Круглые скобки - первые, поэтому обращение \1 идёт к ним. Но не просто к выражению, как в случае с числами в фигурных скобках, а к <i>результату</i> этого выражения. То есть поле выше примет от вас сначала букву латинского алфавита, а потом - то же, что вы записали до этого, и в поле в итоге будет две одинаковые буквы латинского алфавита, причём они должны быть также либо обе заглавные, либо обе строчные.
					<p>Пример с двумя скобками и обращениями к ним: <text class="nwrp">pattern="([A-z])(\d)\2\1"</text>.
					<p><input type="text" pattern="([A-z])(\d)\2\1" placeholder="N44N" required>
					<p>Здесь сначала идёт буква, затем цифра, а после - они же, но в обратном порядке. Не забывайте: вы должны повторить ввод тех же символов, что написали первыми. Поле примет записи по типу "d33d, Z00Z" и прочие "зеркальные" тексты.
					<p>Кстати, есть один любопытный момент: если вы напишете референс к скобке, идущей после самого референса, то этот паттерн уже не сможет работать правильно и никакой ввод не посчитает валидным, но при этом это не будет считаться ошибкой, и в консоли браузера ничего не будет об этом сказано. Например, если мы в примере выше переместим обращение ко второй скобке, и получим <text class="nwrp">pattern="([A-z])\2(\d)\1"</text>, вы уже ничего не сможете вписать в такое поле - референс будет обращаться к тому, чего для него не существует (ведь он проверяет все скобки, идущие ДО него, а не после). Также паттерн не будет правильно работать при обращении к несуществующему номеру скобки, поэтому будьте внимательней.
					<p>Реалистичный пример: предположим, пользователь должен ввести номер карты, состоящий из 11 цифр, где каждые 4 цифры разделены точками, либо пробелами, либо дефисами (во всей записи разделители должны быть одинаковыми!). Конечно, можно после каждой четвёрки цифр писать в квадратных скобках набор из точки, пробела и дефиса, но вдруг пользователь захочет первые четыре цифры разделить точкой, а последние - дефисом? Трудно будет правильно прочитать такую запись. Вот, как можно решить данную проблему: <text class="nwrp">pattern="\d{4}([. -])\d{4}\1\d{3}"</text>.
					<p><input type="text" pattern="\d{4}([. -])\d{4}\1\d{3}" placeholder="1234-5678-901" required>
					<p>Компьютер прочитал, что пользователь ввёл на месте выражения в круглых скобках, и после потребует повтора этой же записи, поэтому пользователь не сможет ввести что-нибудь вроде "1234 5678.901".
					<p>Обилие обратных слешей поначалу сильно путает, но постарайтесь вспомнить, какой символ что обозначает, и вам станет гораздо проще. Чтобы было ещё удобнее - разделяйте круглыми скобками все части выражений. Конечно, тогда для референса придётся их считать, но вы точно не запутаетесь. Запись выше можно сделать немного понятнее: <text class="nwrp">"(\d{4})([. -])(\d{4})\2(\d{3})"</text>. Единичка стала двойкой, потому что раньше эти скобки были единственными, а теперь они по счёту вторые.
					<p>Как работает референс со вложенными скобками? Например, <text class="nwrp">"((\d{2})([A-z]{2})-)\1\2-\3"</text>.
					<p><input type="text" pattern="((\d{2})([A-z]{2})-)\1\2-\3" placeholder="93sW-93sW-93-sW" required>
					<p>В данном случае первый номер присваивается самой большой скобке - той, что содержит две другие. Второй номер у первой скобки слева внутри большой скобки <b>(\d{2})</b>, третий - у правой <b>([A-z]{2})</b>.
					<p>Последний пример с ещё более сложной вложенностью скобок: <b>"(((\d)([a-z])[A-Z])([0-5]))((\s)(\d)(\s)([.]))\2\8\10"</b>.
					<p><input type="text" pattern="(((\d)([a-z])[A-Z])([0-5]))((\s)(\d)(\s)([.]))\2\8\10" placeholder="7vT0 2 .7vT2." required>
					<p>Итак, нумерация происходит всё ещё слева направо, начиная с самой первой большой скобки, заканчивая скобками с точкой. Как видите, обращение может быть и к скобке с номером более 9. Чтобы было чуть проще считать, скобки с цифрами 0-5 - пятые (так случайно совпало). Распишем более подробно и обозначим все скобки цветом:
					<br><br><center>Первые скобки: <text style="color:FireBrick;background:Gainsboro;">(((\d)([a-z])[A-Z])([0-5]))</text>((\s)(\d)(\s)([.]))\2\8\10
					<br>
					<br>Вторые скобки: (<text style="color:LightSalmon;background:Gainsboro;">((\d)([a-z])[A-Z])</text>([0-5]))((\s)(\d)(\s)([.]))\2\8\10
					<br>
					<br>Третьи скобки: ((<text style="color:Yellow;background:Gainsboro;">(\d)</text>([a-z])[A-Z])([0-5]))((\s)(\d)(\s)([.]))\2\8\10
					<br>
					<br>Четвёртые скобки: (((\d)<text style="color:YellowGreen;background:Gainsboro;">([a-z])</text>[A-Z])([0-5]))((\s)(\d)(\s)([.]))\2\8\10
					<br>
					<br>Пятые скобки: (((\d)([a-z])[A-Z])<text style="color:MediumAquamarine;background:Gainsboro;">([0-5])</text>)((\s)(\d)(\s)([.]))\2\8\10
					<br>
					<br>Шестые скобки: (((\d)([a-z])[A-Z])([0-5]))<text style="color:MediumTurquoise;background:Gainsboro;">((\s)(\d)(\s)([.]))</text>\2\8\10
					<br>
					<br>Седьмые скобки: (((\d)([a-z])[A-Z])([0-5]))(<text style="color:DodgerBlue;background:Gainsboro;">(\s)</text>(\d)(\s)([.]))\2\8\10
					<br>
					<br>Восьмые скобки: (((\d)([a-z])[A-Z])([0-5]))((\s)<text style="color:SteelBlue;background:Gainsboro;">(\d)</text>(\s)([.]))\2\8\10
					<br>
					<br>Девятые скобки: (((\d)([a-z])[A-Z])([0-5]))((\s)(\d)<text style="color:DarkSlateBlue;background:Gainsboro;">(\s)</text>([.]))\2\8\10
					<br>
					<br>Десятые скобки: (((\d)([a-z])[A-Z])([0-5]))((\s)(\d)(\s)<text style="color:RebeccaPurple;background:Gainsboro;">([.])</text>)\2\8\10
					</center><p>Если вам неудобно искать все скобки целиком, можно находить первые открывающиеся скобки и нумеровать их, а уже после смотреть, где они закрываются. Если в данной записи вы слева направо посчитаете все открывающиеся скобки, вы получите те же номера:
					<center><br><text style="background:Gainsboro">
					<text style="color:FireBrick">(</text>
					<text style="color:LightSalmon">(</text>
					<text style="color:Yellow">(</text>\d)
					<text style="color:YellowGreen">(</text>[a-z])[A-Z])
					<text style="color:MediumAquamarine">(</text>[0-5]))
					<text style="color:MediumTurquoise">(</text>
					<text style="color:DodgerBlue">(</text>\s)
					<text style="color:SteelBlue">(</text>\d)
					<text style="color:DarkSlateBlue">(</text>\s)
					<text style="color:RebeccaPurple">(</text>[.]))
					</text>\2\8\10</center>
					<p>Конечно, в реальной жизни не будет настолько сложных примеров, и всё будет ограничено вводом правильных разделителей для цифр какой-нибудь карты. А ещё, если вам попросту неудобно без скобок, но как-то нужно упростить нумерацию, воспользуйтесь специальным символом <b>?:</b>, ставящимся сразу после ОТКРЫТИЯ скобок. Он означает, что текущие скобки не участвуют в общей нумерации, результирующие данные, соответствующие этим скобкам, не запоминаются, и их номер переходит к следующим скобкам. Например, в записи "((\d{2})([A-z]{2})-)" поставим этот символ в самую первую и в третью скобки: "(?:(\d{3})(?:[A-z]{2})-)". В итоге запоминаются только данные второй (а теперь уже первой) скобки, содержащей две цифры. Значение паттерна следующего поля - <text class="nwrp">"(?:(\d{2})(?:[A-z]{2})-)\1"</text>.
					<p><input type="text" pattern="(?:(\d{2})(?:[A-z]{2})-)\1" placeholder="93sW-93" required>
					</p>
				</div>
				
				<div class="page hiddenpage">
					<p>Другой крайне важный для использования метод - <i>просмотр вперёд и назад</i>. Возможно, по ходу уроков вы спрашивали себя, почему нельзя просто написать кучу символов, необходимых для ввода, в одни общие скобки, а после в фигурных указать, сколько этих символов мы хотим видеть? Но у нас есть способ <u>заранее</u> определить, сколько всего символов должно быть в вводимой строке (хотя мы можем определить не только это!), с помощью уже знакомого нам вопросительного знака. Просмотры вперёд и назад бывают позитивными и негативными, и в одном выражении их может быть сколько угодно, пока они не противоречат друг другу.
					<p><b><u>Просмотр вперёд: позитивный</u></b>
					<p>Просмотр вперёд означает, что мы пишем скобки, в которых записываем какое-то условие для вводимого далее текста. Выглядит это вот так: <b>(?=шаблон)</b>. Позитивным он называется потому, что из следующих далее символов считает валидными все, что совпадают с шаблоном, а так как это просмотр <i>вперёд</i>, то он игнорирует все ранее введённые символы. Например, следующее поле имеет паттерн <text class="nwrp">"(?=.{2,6}$)[A-zА-я\d]*"</text>.
					<p><input type="text" pattern="(?=.{2,6}$)[A-zА-я\d]*" placeholder="k0tиК" required>
					<p>В данной записи появилось целых два ранее нам неизвестных спецсимвола: точка и знак доллара. Точка означает ровно один абсолютно любой символ, а не какое-то количество предшествующих символов (поэтому мы не обсуждали её, когда изучали знак вопроса, плюс и звёздочку), и в данном случае обозначает любые введённые после скобки с просмотром символы. Идущие далее фигурные скобки означают, что этот самый любой символ может встречаться от двух раз. Знак доллара означает конец строки и нужен для того, чтобы при просмотре всего введённого текста компьютер понял, где остановиться. Без знака доллара он бы принял на ввод текст длиной от двух символов и до бесконечности, пусть даже в скобках и обозначена верхняя граница в шесть символов. Звёздочка после квадратных скобок нужна, чтобы они позволили ввести более одного символа (как вы помните, квадратные скобки без обозначений (вроде плюса, звёздочки или чисел в фигурных скобках) требуют ввести ровно один символ; без звёздочки поле никак нельзя было бы сделать валидным - начало паттерна противоречило бы его концу: в начале было бы "<i>от двух до шести</i> любых из введённых далее символов", а в конце - "<i>ровно один</i> символ из набора в квадратных скобках").
					<p>Добавим просмотр вперёд для уже знакомого нам примера с вводом цифры в начале, после которой должно быть от двух до шести букв: "[0-9][А-яЁёA-z]{2,6}". Для этого заменим звёздочкой фигурные скобки в конце, а перед квадратными скобками с буквами добавим круглые, в которых пропишем условие - от двух до шести символов. Всё вместе будет выглядеть вот так: <text class="nwrp">"[0-9](?=.{2,6}$)[А-яЁёA-z]*"</text>.
					<p><input type="text" pattern="[0-9](?=.{2,6}$)[А-яЁёA-z]*" placeholder="3oмБNe" required>
					<p>Данный паттерн означает, что сначала в тексте обязательно идёт любая цифра, а затем - от двух до шести букв латинского или кириллического алфавита, оканчивающих всю строку (на это указывает знак доллара). Не забудьте о звёздочке в конце!
					<p>Как мы уже обсуждали ранее, просмотр может искать не только какое-то количество символов, но и определённую последовательность символов и целые слова, но для этого куда лучше использовать <i>негативный</i> просмотр вперёд/назад.
					<p><b><u>Просмотр вперёд: негативный</u></b>
					<p>Всё также этот просмотр проверяет написанные после него символы, но на этот раз он посчитает всё, что совпадает с его условием, невалидным.
					<p>Предположим, у нас всё то же условие для никнейма: сначала цифра, потом буквы (скажем, их может быть больше - от двух и до десяти). Допустим, что это никнейм на какой-нибудь сайт о диетах, и людям наверняка будет грустно, если у кого-то в никнейме будет что-нибудь вкусное, что этим людям нельзя есть. Немного сократим нашу запись, чтобы логины могли быть только из русских букв: "[0-9][А-яЁё]{2,10}". Теперь между цифрами и буквами добавим негативный просмотр. Его обозначение - <b>(?!шаблон)</b>. Допустим, никнейм не может содержать слово "пончик", тогда вид негативного просмотра будет таким: <text class="nwrp">"[0-9](?!пончик)[А-яЁё]{2,10}"</text>.
					<p><input type="text" pattern="[0-9](?!пончик)[А-яЁё]{2,10}" placeholder="9ОопончикоО" required>
					<p>Но тут есть одна проблема. Если перед словом "пончик" будут стоять ещё символы, негативный просмотр не воспример этот текст, ведь он настроен исключительно на слово "пончик" (причём слово "Пончик" или "пОнЧиК" он проигнорирует). Чтобы обозначить, что перед этим словом (и после него) может стоять любое количество символов, с двух сторон поставим по точке (что обозначает любой символ), а после точки - по звёздочке (что означает, что этот любой символ может встречаться любое количество раз): <b>"[0-9](?!<text class="nwrp">.*пончик.*</text>)[А-яЁё]{2,10}"</b>.
					<p><input type="text" pattern="[0-9](?!.*пончик.*)[А-яЁё]{2,10}" placeholder="5вИнОгРаДиК" required>
					<p>Такой просмотр вперёд довольно удобен, когда нужно исключить одно-два сочетания символов. Для исключения большого количества символов куда проще использовать скрипты, которые могут работать с большим количеством паттернов. Но немного побалуемся и исключим любое написание слова "пончик" с помощью круглых скобок и знака "или" (вертикальной черты): <b>"[0-9](?!.*(П|п)(О|о)(Н|н)(Ч|ч)(И|и)(К|к).*)[А-яЁё]{2,10}"</b>.
					<p><input type="text" pattern="[0-9](?!.*(П|п)(О|о)(Н|н)(Ч|ч)(И|и)(К|к).*)[А-яЁё]{2,10}" placeholder="7витаминкаА" required>
					<p>Можно также написать каждую пару букв в квадратных скобках (ведь они, как известно, рекомендуют к вводу только один из записанных в них символов) и получить [Пп][Оо][Нн][Чч][Ии][Кк]. Такая запись исключает абсолютно все варианты написания слова "пончик", сколько бы в нём ни было заглавных и строчных букв. Страдающие без пончиков люди спасены!
					</p>
				</div>
				
				<div class="page hiddenpage">
					<p>Просмотр назад проверяет то, что написано до него и также может быть позитивным <b>(?<=шаблон)</b> и негативным <b>(?&#60;!шаблон)</b>.
					<p><b><u>Просмотр назад: позитивный</u></b>
					<p>Как и позитивный просмотр вперёд, просмотр назад посчитает валидным всё, что совпадает с его шаблоном. Вот первый пример: <text class="nwrp">"[A-z]*(?<=^.{2,3}$)"</text>.
					<p><input type="text" pattern="[A-z]*(?<=^.{2,3}$)" placeholder="SaD" required>
					<p>Здесь у нас сначала идёт сколько угодно латинских букв, но дальнейшие скобки регулируют их количество. Заметили карет ^? В просмотрах вперёд и назад он обозначает начало строки и крайне необходим, если мы хотим регулировать всё от самого начала. А чтобы регулировалось всё ещё и до самого конца, мы этот самый конец обозначили с помощью нашего нового знакомого - знака доллара. Итак, наш просмотр назад проверяет, чтобы любые введённые ранее символы (обозначенные точкой) были введены от двух до трёх раз. Ввод большего количества символов, либо символов, не являющихся латинскими буквами, сделает поле невалидным.
					<p>Все условия, написанные после просмотра назад, будут им проигнорированы: <text class="nwrp">"[A-z]*(?<=^.{2,3})\d{2}"</text>.
					<p><input type="text" pattern="[A-z0-9]*(?<=^.{2,3})\d{2}" placeholder="bOx37" required>
					<p>Обратите внимание: если мы хотим поставить дополнительные условия после просмотра (как две цифры в примере выше), в самом просмотре знак доллара не ставится, иначе условие будет невозможно выполнить: просмотр будет требовать два-три символа (в данном случае латинские буквы), которыми начинается и оканчивается строка, однако дополнительное условие будет требовать ещё две цифры после конца строки.
					<p><b><u>Просмотр назад: негативный</u></b>
					<p>Как и негативный просмотр вперёд, такой тип просмотра назад посчитает невалидным всё, что совпадает с его шаблоном. Такой просмотр использует служебный символ &#60; в сочетании с восклицательным знаком !, что порой заставляет текстовые редакторы неверно отображать часть разметки после сочетания этих символов. Тем не менее, в большинстве браузеров негативный просмотр назад работает корректно.
					<p>Представим, что на форуме, посвящённом орнитологии (науке, изучающей птиц), можно использовать только никнеймы, являющиеся названиями и прозвищами разных птиц, и ни в коем случае нельзя брать имена, олицетворяющие хищных врагов этих птиц - например, кошек. Попробуем запретить ввод никнеймов, содержащих слова "кот" или "кошка" в разных видах. Основным условием будет то, что никнейм должен быть длиной от 3 до 11 символов и содержать только буквы кириллического алфавита: [А-яЁё]{3,11}. Первая часть паттерна у нас уже есть, осталось только добавить просмотр назад. Вот так будет выглядеть условие для слова "кот", учитывающее символы до и после этого слова: <text class="nwrp">"[А-яЁё]{3,11}</text><b>(?&#60;!^.*[Кк][Оо][Тт].*$)"</b>.
					<p><input type="text" pattern="[А-яЁё]{3,11}(?<!^.*[Кк][Оо][Тт].*$)" placeholder="жУрАвЛиК" required>
					<p>Теперь нам необходимо как-то дополнить это условие, чтобы нельзя было вводить и слово "кошка". Это слово начинается с тех же двух букв, поэтому с помощью связки "или" мы можем добавить вариативность окончаний: <b>"(?&#60;!^.*[Кк][Оо]([Тт]|[Шш][Кк][Аа]).*$)"</b>.
					<p><input type="text" pattern="[А-яЁё]{3,11}(?<!^.*[Кк][Оо]([Тт]|[Шш][Кк][Аа]).*$)" placeholder="оОкакадуОо" required>
					<p>Работает! Но мы можем пойти ещё дальше, и запретить также ввод и слова "котёнок", причём это слово может быть написано как через ё, так и через е. Чтобы несколько сократить запись, не будем дублировать скобки с буквой Т, а добавим после неё вариативность окончания - ещё одни круглые скобки, в которых будут остальные буквы слова "котёнок": <b>[Кк][Оо]([Тт]([ЁёЕе][Нн][Оо][Кк]))</b>. Но этих букв может и не быть - поэтому после скобок поставим знак вопроса, который, как мы помним, означает, что предыдущий символ либо предыдущие скобки могут быть написаны ни одного раза, либо ровно один раз: <b>[Кк][Оо]([Тт]([ЁёЕе][Нн][Оо][Кк])?)</b>. После этого объединим полученный паттерн с уже имеющейся половиной - окончанием слова "кошка": <b>"[А-яЁё]{3,11}(?&#60;!^.*[Кк][Оо]([Тт]([ЕеЁё][Нн][Оо][Кк])?|[Шш][Кк][Аа]).*$)"</b>.
					<p><input type="text" pattern="[А-яЁё]{3,11}(?<!^.*[Кк][Оо]([Тт]([ЕеЁё][Нн][Оо][Кк])?|[Шш][Кк][Аа]).*$)" placeholder="уТоЧкА" required>
					<p>На самом деле, предыдущий паттерн (для слов "кот" и "кошка") вполне успешно фильтровал и слово "котёнок", ведь оно также содержит в себе слово "кот". Но мы составили последний паттерн для того, чтобы лучше запомнить используемые в паттернах инструменты, и на конкретных примерах разобраться в правилах их составления.
					</p>
				</div>
					
				<div class="page hiddenpage">
					<p>Немного отвлечёмся от сферических требований в ваккууме и составим регулярные выражения для предполагаемой формы регистрации на сайте.
					<p>Начнём с выражения для имени. Условия: оно должно начинаться с заглавной буквы, быть не короче двух символов и не иметь вообще ничего в своей записи, кроме букв кириллического алфавита. Решение: <text class="nwrp">"[А-ЯЁ][а-яё]{2,}"</text>.
					<p><input type="text" pattern="[А-ЯЁ][а-яё]{1,}" placeholder="Василиса" required>
					<p>Следующая задача: создаём паттерн для фамилии. Предположим, что наш ресурс создан исключительно для членов какой-нибудь семьи с фамилиями Котов, Котова, Пряничкин, Пряничкина, Соловьёв, Соловьёва. Решение: <b>"(Котов|Пряничкин|Соловьёв)[а]?"</b>.
					<p><input type="text" pattern="(Котов|Пряничкин|Соловьёв)[а]?" placeholder="Пряничкина" required>
					<p>Теперь выберем паттерн для отчества. Здесь можно обойтись и тем, что мы написали для имени, но мы не любим простые задачи, поэтому усложним вид паттерна и добавим вариативность окончаний: <br><b>"[А-ЯЁ][а-яё]*(((ов|ев|ин|ич)([а]|((ич)?(на)?))?))"</b>.
					<p><input type="text" pattern="[А-ЯЁ][а-яё]*(((ов|ев|ин|ич)([а]|((ич)?(на)?))?))" placeholder="Ильинична" required>
					<p>Что обычно нужно ввести дальше? Пожалуй, номер телефона. Допустим, что он может начинаться с +7 или 8, код должен быть в круглых скобках, а остальные цифры должны разделяться пробелами или чёрточками (но только чем-то одним!). Вот наш вариант с использованием референса, ссылающегося на скобку с выбранным пользователем знаком разделения (пробелом или дефисом): <b>"(\+7|8)[(]\d{3}[)]\d{3}([ -])\d{2}\2\d{2}"</b>. Не забудьте о том, что знак плюса - служебный и нуждается в экранировании, как и круглые скобки - их мы заключили в квадратные, чтобы не было обилия слешей (но было обилие скобок :D).
					<p><input type="text" pattern="(\+7|8)[(]\d{3}[)]\d{3}([ -])\d{2}\2\d{2}" placeholder="8(999)123 45 67" required>
					<p>Далее можно ввести почту. Предположим, что она может начинаться со строчной латинской буквы и содержать также строчные латинские буквы, дефисы, точки, символы подчёркивания и цифры (всё вместе не длиннее 15 символов), затем должен идти знак @, после которого мы должны ввести от двух до 8 символов, а затем должна стоять точка, после которой может быть от двух до четырёх символов. Самое сложное - в первой части почты: <b>"[a-z][a-z\d._-]{1,14}@[a-z]{2,8}\.[a-z\d]{2,4}"</b>.
					<p><input type="text" pattern="[a-z][a-z\d._-]{1,14}@[a-z\d]{2,8}\.[a-z]{2,4}" placeholder="example_mail@rambler.org" required>
					<p>Самое интересное - пароль. Как ни странно, но просмотр вперёд может включить в себя абсолютно все ограничения, и их не придётся писать дальше. Чтобы обозначить, что необходимые для пароля символы могут стоять в любом месте, перед ними мы ставим точку и звёздочку, и их же ставим после всех условий, чтобы показать, что сам пароль должен состоять из любого количества любых символов, среди которых мы и будем искать соответствия условиям. Итак, пароль длиной от 8 символов, включающий заглавные и строчные буквы кириллического и латинского алфавита, как минимум одну цифру и спецсимвол: <b>"(?=.{8,}$)(?=.*[\d])(?=.*[A-zА-яЁё])(?=.*[A-ZА-ЯЁ])(?=.*[-_.,+?!*#$%^;:]).*"</b>. Кстати, такое поле должно иметь тип вовсе не text (а какой?), но мы оставили текстовый тип, чтобы вы могли видеть, какой текст принимается как валидный.
					<form>
						<input type="text" pattern="(?=.{8,}$)(?=.*[\d])(?=.*[A-zА-яЁё])(?=.*[A-ZА-ЯЁ])(?=.*[-_.,+?!*#$%^;:]).*" placeholder="Это_Пароль1" title="Пароль должен быть длиной от 8 символов и включать как минимум одну заглавную и строчную букву, цифру и спецсимвол" required>
					</form>
					<p>Вы обратили внимание на текст, всплывающий под или над полем, когда вы нажимаете enter? Он пишется в атрибут <b>title</b>!
					</p>
				</div>
				<div class="bottomthings">
					<button id="prevlesson">Урок 4</button>
					<button id="prev">Назад</button>
					<p id="current">Страница 1 из 7</p>
					<button id="next">Вперёд</button>
					<button id="nextlesson">Все уроки</button>
					<script src="../../js/pagesswitch.js"></script>
				</div>
			</div>
		</div>
		
		<script>
		
		prevlessonbutton.addEventListener("click", prevles);
		nextlessonbutton.addEventListener("click", nextles);
			
			function nextles() {
				let go = confirm("Вы точно хотите вернуться к списку уроков?");
				if (go == true) {
					document.location = "htmlmain.html";
					}
				}
			
			function prevles() {
				let go = confirm("Вы точно хотите вернуться к предыдущему уроку?");
				if (go == true) {
					document.location = "l4.html";
					}
				}
			
			function show1() {
				document.getElementById("q15").checked = true;
				document.getElementById("q2").placeholder = "\\W";
				document.getElementById("q31").checked = true;
				document.getElementById("q32").checked = false;
				document.getElementById("q33").checked = false;
				document.getElementById("q34").checked = true;
				document.getElementById("q35").checked = false;
				document.getElementById("q36").checked = true;
				document.getElementById("q37").checked = false;
				document.getElementById("q42").checked = true;
				document.getElementById("q53").checked = true;
				document.getElementById("showme1").style.display = "none";
				document.getElementById("hideme1").style.display = "inline-block";
				}
			
			function hide1() {
				document.getElementById("q15").checked = false;
				document.getElementById("q2").placeholder = "";
				document.getElementById("q31").checked = false;
				document.getElementById("q32").checked = false;
				document.getElementById("q33").checked = false;
				document.getElementById("q34").checked = false;
				document.getElementById("q35").checked = false;
				document.getElementById("q36").checked = false;
				document.getElementById("q37").checked = false;
				document.getElementById("q42").checked = false;
				document.getElementById("q53").checked = false;
				document.getElementById("showme1").style.display = "inline-block";
				document.getElementById("hideme1").style.display = "none";
				}
			
			function why1() {
				document.getElementById("why1").style.display = "none";
				document.getElementById("whyclose1").style.display = "inline-block";
				document.getElementById("bcs1").style.display = "inline-block";
				}
			
			function whyclose1() {
				document.getElementById("why1").style.display = "inline-block";
				document.getElementById("whyclose1").style.display = "none";
				document.getElementById("bcs1").style.display = "none";
				}
			
			function why2() {
				document.getElementById("why2").style.display = "none";
				document.getElementById("whyclose2").style.display = "inline-block";
				document.getElementById("bcs2").style.display = "inline-block";
				}
			
			function whyclose2() {
				document.getElementById("why2").style.display = "inline-block";
				document.getElementById("whyclose2").style.display = "none";
				document.getElementById("bcs2").style.display = "none";
				}
		</script>
	</body>
</html>